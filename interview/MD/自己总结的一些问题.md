- 讲一下TCP三次握手的过程

```
第一次握手：客户端向服务端发送一个SYN包，表示自己想要建立连接
第二次握手：服务器收到SYN包，如果同意建立连接，那么会向客户端发送一个SYN+ACK包，表示自己同意建立连接
第三次握手：客户端收到服务端发来的SYN+ACK包，再次向服务器发送一个ACK包，同时进入已建立连接状态，同时服务器收到客户端发送的ACK包后也进入已建立连接状态
```

- 为什么一定要是三次握手，两次握手为什么不行

```
如果是两次握手，那么服务器无法确认客户端是否接受到了发给客户端的SYN+ACK包，客户端也无法确认服务端是否收到自己发送的ACK包，这样可能导致连接建立失败
```

- 线程和进程是什么关系

```
线程是CPU调度的最小单位，进程是资源分配的最小单位。
```

- 进程和线程他们之间分别是怎么样进行通信的呢

```

```

- 心之易项目难点

```
1. 更新题目时。难点：更新题目时可能增加，删除，个数不确定，同时不能先删后增
2. 母题关联知识点必须是子题共有的知识点。难点：没有现成的streamAPI，要自己实现，功能较为复杂
3. 题目有选择题和加答题，使用策略+工厂模式优化代码结构。
```

- 说一下什么是发射

```
反射就是在运行时才知道要操作的类是什么，并且可以在运行时获取类的完整构造，并调用对应的方法
```

- 什么是Spring

```
From configuration to security, web apps to big data—whatever the infrastructure needs of your application may be, there is a Spring Project to help you build it. Start small and use just what you need—Spring is modular by design.
```

- Spring中@Transactional注解失效的场景

```
- 使用非public来修饰方法
	因为Transactional是通过Spring AOP来实现的，而Spring AOP是通过动态代理实现的，在生成代理时会判断，如果方法是非public修饰的方法，就不会生成代理对象，自然也就无法自动执行事物了。
- 自己捕获了异常
	如果我们自己捕获了异常，那么动态代理的cache就捕获不到异常，那么自然也就不会回滚事物
- 调用类内中使用Transactional修饰的方法
	类中调用Transactional方法，本质上使用this对象调用方法，没有使用动态代理的对象来执行方法，因此就没有开启事物的过程，自然也就会导致Transactional失效。
	
-- 但是似乎有些地方规定，不要使用声明式事物。有下面几点原因：
1. 声明式事物的失效场景很多，稍不注意就会踩坑，导致事物失效。
2. Transactional使用AOP来控制事物，如果有异常抛出，才会回滚事物。有这么一个场景，一个方法中有很多个代理，其中一个代理捕获到了异常而导致没有抛出异常，导致事物没有回滚。
3. 还有就是声明式事物的粒度比较大，通常在写操作之前，会有很多的读操作，或者一些其他的操作，而这些东西，是没有必要放到事物中的。粒度太大会导致拉长整个事物，事物变长就会占用数据库的连接，导致连接无法释放，一旦请求量比较大，就容易拖垮数据库。
